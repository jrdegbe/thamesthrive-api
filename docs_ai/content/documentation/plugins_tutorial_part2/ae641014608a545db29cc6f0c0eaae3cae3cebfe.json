{
  "file_name": "docs/plugins/tutorial/part2.md",
  "questions": [
    "What is the process for setting up and running a plugin?",
    "How to set up a plugin?",
    "How to run a plugin?",
    "What is the default configuration for a plugin?",
    "What is the validation process for a plugin configuration?"
  ],
  "answer": "f.config = config\n\n    async def run(self, payload: dict, in_edge=None):\n        if self.event.type == self.config['event-type']:\n            return Result(port=\"MyEvent\", value=payload)\n        else:\n            return Result(port=\"NotMyEvent\", value={})\n```\n\nThat's it for the moment.\n\nThe whole process is as follows. The system registers the plugin and saves in it the default configuration from\nthe `Spec.init` property. In our case it is:\n\n```json\n{\n  \"event_type\": \"\"\n}\n```\n\nWhen the user moves the plug-in to the workflow and starts it, the configuration from the plug-in is put as a parameter\nto the `set_up` method. In the method, we set `self.config` to the value from the parameter (i.e. the one\nfrom `spec.init`).\nIf the user changed the configuration in the editor before the first run, the changed values are of course substituted\nas the config parameter.\n\nThen `self.config` is used to read the value of `event-type` and perform a\ncomparison `if self.event.type == self.config['event-type']` in the run method.\n\nComplete code looks like this:\n\n=== \"/ThamesThrive/process_engine/action/v1/my_plugin_folder/my_plugin.py\"\n\n    ```python\n    from ThamesThrive.service.plugin.runner import ActionRunner\n    from ThamesThrive.service.plugin.domain.result import Result\n    from ThamesThrive.service.plugin.domain.register import Plugin, Spec, MetaData\n    \n    class MyPlugin (ActionRunner):\n    \n        config: dict\n        \n        async def set_up(self, config):\n          self.config = config\n        \n        async def run(self, payload: dict, in_edge = None):\n            if self.event.type == self.config['event-type']:\n                return Result(port = \"MyEvent\", value = payload)\n    \n            else:\n                return Result(port = \"NotMyEvent\", value = {})\n    \n    def register () -> Plugin:\n        return Plugin (\n    \n            start = False,\n            spec = Spec (\n                module = __name__,\n                className = 'MyPlugin',\n                init = {\n                   \"event_type\": \"\"\n                },\n                inputs = [\"payload\"],\n                outputs = [\"MyEvent\", \"NotMyEvent\"],\n                version = '0.1',\n                license = \"MIT\",\n                author = \"Your Name\"\n            ),\n            metadata = MetaData (\n                name = \"My first plugin\",\n                desc = 'Checks if the event type is equal to my-event.',\n                group = [\"Test plugin\"]\n            )\n        )\n    ```\n\n!!! Info\n    Please check if the code works step by step. You do not have to implement everything to check if the code works.\n    Every time you complete some part of the tutorial you may save the changes and reinstall plugins and see how it\n    works in the workflow editor. Installation of the changed plugin can be done in the workflow editor by clicking\n    the `Reinstall plugins` button.\n\n## Validation\n\nNote that although the code works, there may be a situation in which the user in the json editor deletes the initialized\nvalue\n\n```json\n{\n  \"event_type\": \"\"\n}\n```\n\nand puts any other, for example:\n\n```json\n{\n  \"Type\": \"\",\n  \"Position\": 1\n}\n```\n\nThen our code will not work, and we will get `KeyError` when trying to read the value in `self.config['event_type']`.\nSo we need a validation that will not allow the user to enter incorrect values.\n\nFor this we will use the `PluginConfig` object.\n\n```python\nfrom pydantic import validator\nfrom ThamesThrive.service.plugin.domain.config import PluginConfig\n\n\nclass Configuration(PluginConfig):\n    event_type: str  # (1)\n\n    @validator(\"event_type\")  # (2)\n    def must_not_be_empty(cls, value):\n        if len(value) == 0:\n            raise ValueError(\"Event type can not be empty.\")\n        return value\n```\n\n1. Tells that the object has a property named `event_type` and it is of type string. `None` value is not allowed.\n2. `@validator(\"event_type\")` and the method below checks if the value of event_type is not empty.\n\nThe above class defines what our configuration "
}
