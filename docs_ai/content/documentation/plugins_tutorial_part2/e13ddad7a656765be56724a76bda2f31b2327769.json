{
  "file_name": "docs/plugins/tutorial/part2.md",
  "questions": [
    "How to configure a plugin in ThamesThrive?",
    "What is the life cycle of a plugin in ThamesThrive?",
    "How to provide a dictionary with configuration values in ThamesThrive?",
    "How to use the \"set_up\" method to read the initialized configuration in a plugin?"
  ],
  "answer": "# Part 2: Configuring the plugin in ThamesThrive\nIn the next part of our tutorial, we will learn how to configure a plugin and how to add a configuration form to that\nplugin.\n\nIn the previous tutorial we wrote the plugin that performs a simple action and checks if the event we are processing\nis equal to \"my-type\". Our code looked like this:\n\n!!! Info\n    Please click (+) to see the comments for the code\n\n```python\nif self.event.type == \"my-event\":  # (1)\n    return Result(port=\"MyEvent\", value=payload)\nelse:\n    return Result(port=\"NotMyEvent\", value={})\n```\n\n1. `self.event` gets the event that is being processed from the internal workflow state.\n\nYou can see that such plugin is not very useful, because the user cannot configure it to change \"my-event\" to any\ndefined event type. Let's try to change that.\n\nFrom the previous tutorial, we remember that the plugin has the following life cycle:\n\n    __init __ ()\n    async set_up (config)\n    async run (input_payload)\n    async close ()\n\nIt is easy to notice that it has a `set_up` method that accepts the `config` parameter, which is the plug-in's\nconfiguration. In the ThamesThrive system, the configuration is performed while editing the plug-in. We can do this in two\nways.\n\nThe first by providing a dictionary with configuration values (Below is a screenshot showing such a configuration in the\nJSON Editor and Configuration Form)\n\n=== \"JSON configuration editor\"\n    ![JSON configuration editor](../../images/JSON_configuration_editor.png)\n=== \"Configuration form\"\n    ![Configuration form](../../images/configuration_form.png)\n\nThe second way is to complete the form. It is related to the JSON configuration in such a way that when filling in the\nform fields, we automatically fill/change the JSON object.\n\n\n\nThe first way is available out-of-the-box. Developer defines the default JSON object when registering the plugin and\nthis is it. This object will appear in the `set_up` method as a `config` parameter.\n\nSo let's expand our plugin with configuration.\n\n## JSON Configuration\n\nIn the register function, we add the following entry in the spec:\n\n```python\ninit = {\n    \"event_type\": \"\"  # (1)\n}\n```\n\n1. We set up `event_type` as empty string. Later user inside the system can change it to something meaningful. The init\n   serves as a default configuration value.\n\nThis way we define that the object should have the \"event_type\" property, which we will use later in the plugin.\n\nThe entire register function should look like this:\n\n```python hl_lines=\"11-13\"\nfrom ThamesThrive.service.plugin.domain.register import Plugin, Spec, MetaData\n\n\ndef register() -> Plugin:\n    return Plugin(\n\n        start=False,\n        spec=Spec(\n            module=__name__,\n            className=MyPlugin.__name__,\n            init={  # (1)\n                \"event_type\": \"\"\n            },\n            inputs=[\"payload\"],\n            outputs=[\"MyEvent\", \"NotMyEvent\"],\n            version='0.1',\n            license=\"MIT\",\n            author=\"Your Name\"\n        ),\n        metadata=MetaData(\n            name=\"My first plugin\",\n            desc='Checks if the event type is equal to my-event.',\n            group=[\"Test plugin\"]\n        )\n    )\n```\n\n1. Configuration initialisation\n\nOK now let's use `event_type` in the plugin. First, we will have to read the initialized configuration and save it to\nthe object.\n\nWe will use the `set_up` method for this.\n\n```python\nfrom ThamesThrive.service.plugin.runner import ActionRunner\n\n\nclass MyPlugin(ActionRunner):\n    config: dict\n\n    async def set_up(self, config):\n        self.config = config\n\n    ...  # (1)\n```\n\n1. The rest of the code\n\nThis way we saved the configuration data in the plugin class.\n\nNow let's use the `self.config` property in the run method and replace __\"my-event\"__ with it.\n\n```python\nfrom ThamesThrive.service.plugin.runner import ActionRunner\nfrom ThamesThrive.service.plugin.domain.result import Result\n\n\nclass MyPlugin(ActionRunner):\n    config: dict\n\n    async def set_up(self, config):\n        sel"
}
