{"file_name": "docs/plugins/tutorial/part3.md", "questions": ["General question: How does the third part of the tutorial explain the use of data references, resources, and connecting to external services in plugins?", "Specific questions:", "1. What is dot notation and how is it used to specify the location of data?", "2. How do you add a field of type \"dotPath\" to a form using the `dotPath` component?", "3. How do you read data entered in a form and retrieve data using dot notation in the run method of a plugin?"], "answer": "# Part 3. Data reference and resource in plugins\nIn the third part of the tutorial, we will learn how to use data references, how to use resources and how to connect to\nexternal services. We will extend our plugin with the following functionality. \n\nThe plugin needs to send the user defined data to be sent to user defined API. We will also have to extend our form with\nthe above data (data, and API endpoint).\n\n## Let's get started\n\nOften when coding a plugin, we want to use the data defined by the user. For example, the user references some data\nfrom the internal state of the workflow that he wants to an external API. To do this he uses so-called dot notation. \nDot notation is a way of specifying the location of the data. It looks like this. \n\n```\n<source>@<path.to.data>\n```\n\nThis is a working example:\n\n```\nevent@properties.email\n```\n\nIt means get the data from the event from its `properties.email`. A full description of all sources and how the data\nreference works can be found [here](../../notations/dot_notation.md).\n\nIn this tutorial we are interested in how to use this entry and retrieve data, and how to put a field in the form that\nwill require a dot notation entry.\n\n## Data reference\n\nLet's start with the form. To add a new field to the form we will use the `dotPath` component and in the `form / FromGroup\n/ FormFields` section we will add the following code:\n\n\n```python\nFormField (\n   id = \"data\",\n   name = \"Data to send\",\n   description = \"Please provide data to send\",\n   component = FormComponent (type = \"dotPath\", props = {\"label\": \"Data to send\"})\n)\n```\n\nThis way we get:\n```python hl_lines=\"10-15\"\nform = Form(groups=[\n    FormGroup(\n        name=\"Event type plugin configuration\",\n        description=\"Define required event type\",\n        fields=[\n            FormField(\n                id=\"event_type\", name=\"Event type\",\n                description=\"Event type to check\",\n                component=FormComponent(type=\"text\", props={\"label\": \"Event type\"})),\n            FormField(\n                id=\"data\",\n                name=\"Data to send\",\n                description=\"Please provide data to send\",\n                component=FormComponent(type=\"dotPath\", props={\"label\": \"Data to send\"})\n            )\n        ]\n    ),\n]),\n```\n\nWith this, we will get a field of this type in the form.\n\n![Dot path form field](../../images/dot_path.png)\n\nThen we need to extend `init` in register function with a `data` field and extend an object that will store the data and\nverify its correctness at the same time.\n\nSo I would add to init:\n\n```python hl_lines=\"3\"\ninit = {\n  \"event_type\": \"\",\n  \"data\": \"\"\n}\n```\n\nand add to the `Configuration` object:\n\n\n```python hl_lines=\"3 12-16\"\nclass Configuration(PluginConfig):\n    event_type: str\n    data: str\n\n    @validator(\"event_type\")\n    def must_not_be_empty(cls, value):\n        if len(value) == 0:\n            raise ValueError(\"Event type can not be empty.\")\n        return value\n\n\n    @validator(\"data\")  # (1)\n    def data_must_not_be_empty(cls, value):\n        if len(value) == 0:\n            raise ValueError(\"Data can not be empty. \")\n        return value\n```\n\n1. Validates the data property. It is defined as string, but it __may not be empty__ string\n\nWe have configuration data, now it's time to read data entered in the form and read data\nfrom [dot notation](../../notations/dot_notation.md).\n\nWe do it as follows:\n\nIn the run method:\n\n```python hl_lines=\"2 3\"\nasync def run(self, payload: dict, in_edge=None):\n    dot = self._get_dot_accessor(payload)  # (1)\n    data_to_send = dot[self.config.data]  # (2)\n\n    if self.event.type == self.config.event_type:\n        return Result(port=\"MyEvent\", value=data_to_send)\n    else:\n        return Result(port=\"NotMyEvent\", value={})\n```\n\n1. Get the DotAccessor object that will convert the dot notation to the data. \n2. Convert anything that is defined in `config.data` to the real data from the workflow and assign it to data_to_send\n\n## Resource\n\nIn many cases, it i", "hash": "4f12b0eb8862d546774165a23a0dbedd5f151cb8"}
